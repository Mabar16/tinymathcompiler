/*
 * generated by Xtext 2.17.1
 */
package sdu.mdsd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import sdu.mdsd.mathinterpreter.MathExp
import sdu.mdsd.mathinterpreter.Math
import sdu.mdsd.mathinterpreter.Plus
import sdu.mdsd.mathinterpreter.Minus
import sdu.mdsd.mathinterpreter.Mult
import sdu.mdsd.mathinterpreter.Div
import java.util.Map
import java.util.HashMap
import sdu.mdsd.mathinterpreter.Expression
import sdu.mdsd.mathinterpreter.Number
import sdu.mdsd.mathinterpreter.Let
import sdu.mdsd.mathinterpreter.Variable
import sdu.mdsd.mathinterpreter.ExternalDecl
import java.util.List
import sdu.mdsd.mathinterpreter.ExternalArguments
import sdu.mdsd.mathinterpreter.ExternalCall

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathinterpreterGenerator extends AbstractGenerator {
	
	var List<ExternalDecl> externalsList
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val exps = resource.allContents.filter(MathExp).toList
		externalsList = resource.allContents.filter(ExternalDecl).toList
		for	(exp : exps){
			System.out.println(exp.display)
		}
		
		val exp = resource.allContents.toIterable.filter(Math).get(0)
		fsa.generateFile("mathexpressions/MathInterpreter.java", exp.compile)
				
	}
	
	def String compile(Math math){
		'''
		package mathexpressions;
		«IF externalsList.length > 0»
		import javatest.ExternalsImpl;
		«ENDIF»
		public class MathInterpreter{
		«IF externalsList.length > 0»
		«externalsList.generateInterfaceDecl»		
		private Externals externals;
		public MathInterpreter(Externals _externals){
		externals = _externals;
		}
		«ENDIF»
			
			public static void main(String[] args){
				«IF externalsList.length > 0»
				MathInterpreter mi = new MathInterpreter(new ExternalsImpl());
				«ELSE»
				MathInterpreter mi = new MathInterpreter(null);
				«ENDIF»
				mi.compute();
				}
			public void compute(){
				«FOR mathExpression : math.expressions»
				«mathExpression.generateMathPrintOut»
				«ENDFOR»
				}
			
		}
		'''
	}
	
	def generateMathPrintOut(MathExp exp){
		'''System.out.println(" «exp.name» = " + «exp.display»);'''
	}
	
	def generateInterfaceDecl(Iterable<ExternalDecl> decls) {
		'''
		public static interface Externals {
			«FOR e:decls»
			public int «e.name»(«FOR t:e.arguments SEPARATOR ","»«t.generateParameters»«ENDFOR»);
			«ENDFOR»
		}
		'''
	}
	
	def generateParameters(ExternalArguments e) '''«e.type» «e.name»'''
	
	def int compute(MathExp math) { 
		math.exp.computeExp(new HashMap<String, Integer>)
	}
	
	def int computeExp(Expression exp, Map<String, Integer> env) {
		switch exp {
			Plus:  exp.left.computeExp(env) + exp.right.computeExp(env)
			Minus: exp.left.computeExp(env) - exp.right.computeExp(env)
			Mult: exp.left.computeExp(env) * exp.right.computeExp(env)
			Div: exp.left.computeExp(env) / exp.right.computeExp(env)
			Number: exp.value
			Variable: env.get(exp.name)
			Let: exp.body.computeExp(env.bind(exp.name,exp.binding.computeExp(env)))
			default: throw new Error("Invalid Expression")
		}
	}
	
	def Map<String, Integer> bind(Map<String, Integer> env, String name, int value){
		val newEnv = new HashMap<String, Integer>(env)
		newEnv.put(name, value)
		newEnv
	}
	
	
	def String display(MathExp math) { 
		math.exp.displayExp(new HashMap<String, Integer>)
	}
	
	def dispatch String displayExp(Expression exp, Map<String, Integer> env) {
		"("+switch exp {
			Plus:  exp.left.displayExp(env) +"+"+ exp.right.displayExp(env)
			Minus: exp.left.displayExp(env) +"-"+ exp.right.displayExp(env)
			Mult: exp.left.displayExp(env) +"*"+ exp.right.displayExp(env)
			Div: exp.left.displayExp(env) +"/"+ exp.right.displayExp(env)
			Number: exp.value+""
			Variable: env.get(exp.name)+""
			Let: exp.body.displayExp(env.bind(exp.name,exp.binding.computeExp(env)))
			default: throw new Error("Invalid Expression")
		}+")"
	}
	
	def dispatch String displayExp(ExternalCall ext, Map<String, Integer> env) {
		'''externals.«ext.method.name»(«FOR exp:ext.args SEPARATOR ","»«exp.displayExp(env)»«ENDFOR»)'''
	}

}
